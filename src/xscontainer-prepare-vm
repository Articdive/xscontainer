#!/usr/bin/env python

import sys
# @todo: Hack for building outside the build system
sys.path.append('/usr/local/lib/python2.7/dist-packages/')
import xscontainer.api_helper as api_helper
import xscontainer.docker as docker
import xscontainer.util as util
import xscontainer.util.log as log

from xscontainer.docker_monitor import api as docker_monitor_api


import optparse
import os
import subprocess


def check_parameters(parser, options, parameters):
    error = False
    for parameter in parameters:
        if not getattr(options, parameter):
            print('Error: Missing parameter --%s' % (parameter))
            error = True
    if error:
        parser.print_help()
        sys.exit(1)


def determine_error_cause(session, vmuuid):
    cause = ""
    try:
        api_helper.execute_ssh(session, vmuuid, ['echo', 'hello world'])
    except util.XSContainerException:
        cause = (cause + "Can't connect at all with the ssh key. Please check" +
                 " the logs inside the VM.")
        return cause
    try:
        api_helper.execute_ssh(session, vmuuid, ['command -v socat || ' +
                                                 'command -v ncat'])
    except util.XSContainerException:
        cause = (cause + "Can't find either socat or ncat in the VM. Please " +
                 "install socat or ncat.")
    dockersocket = "/var/run/docker.sock"
    try:
        api_helper.execute_ssh(session, vmuuid, ['test', '-S', dockersocket])
    except util.XSContainerException:
        cause = (cause + "Can't find the docker's unix socket at %s."
                         % (dockersocket) +
                         " Please install and run Docker.")
    try:
        api_helper.execute_ssh(session, vmuuid, ['test -r "%s" && test -w "%s" '
                                                 % (dockersocket, dockersocket)
                                                 ])
    except util.XSContainerException:
        cause = (cause + "Can't access docker's unix socket. Please add the " +
                         " user to the docker group to provide access.")
    if cause == "":
        cause = "Unknown issue"
    return cause


def ask_yes_or_no():
    while True:
        print("Answer y/n: ")
        choice = raw_input().lower()
        if choice in ('y', 'yes'):
            return True
        elif choice in ('n', 'no'):
            return False


def ask_before_starting():
    print("Would you like to push a pool-specific public SSH key in the "
          + "~/.ssh/authorized_keys-file of the specified VM and user, to "
          + "allow XS to interact with the containers inside the VM?")
    return ask_yes_or_no()


def parse_options():
    print(os.path.basename(__file__)
          +
          " is a tool that simplifies the configuration of RHEL7/CentOS7/OEL7"
          + "and Ubuntu 14.04 VMs to work with the XenServer container addon.\n")
    parser = optparse.OptionParser()
    parser.add_option("-v", "--vmuuid", dest="vmuuid", help="UUID of the VM "
                      + "that should be enabled with the XS container integration.")
    parser.add_option("-u", "--username", dest="username",
                      help="Username which should be used on the VM")
    options = parser.parse_args()[0]
    check_parameters(parser, options, ['vmuuid', 'username'])
    return options


def push_ssh_key(session, vmuuid, username):
    try:
        host = api_helper.get_suitable_vm_ip(session, vmuuid)
    except util.XSContainerException:
        print("Error: Could not make a valid connection to the VM. "
              "Please make sure that there is a SSH server running " +
              "inside the VM that is reachable from Dom0")
        return 1
    api_helper.set_vm_xscontainer_username(session, vmuuid, username)
    api_helper.ensure_idrsa(session)
    print('Attempting to push the public xscontainer key to %s@%s'
          % (username, host))
    key = api_helper.get_idrsa_secret_public(session)
    # The following command is derived from OpenSSH-Client's ssh-copy-id
    cmd = ['/usr/bin/ssh', '%s@%s' % (username, host),
           "umask 077; test -d ~/.ssh || mkdir ~/.ssh ; grep '%s'"
           % key
           + " ~/.ssh/authorized_keys >/dev/null 2>&1 || echo '%s'"
           % key
           + " >> ~/.ssh/authorized_keys && ((test -x /sbin/restorecon && "
           + "/sbin/restorecon ~/.ssh ~/.ssh/authorized_keys "
           + ">/dev/null 2>&1) || true)"]
    process = subprocess.Popen(cmd)
    process.communicate()
    if process.returncode == 0:
        print('Success')
        return 0
    else:
        print('Error: Failed to push the public xscontainer key to %s@%s'
              % (username, host))
        return 1


def verify_monitoring(session, vmuuid, username):
    print('Attempting to refresh the state of the VM')
    try:
        client = api_helper.XenAPIClient(session)
        thevm = api_helper.VM(client, uuid=vmuuid)
        docker.update_docker_version(thevm)
        print("Success.")
        return 0
    except util.XSContainerException:
        cause = determine_error_cause(session, vmuuid)
        print("Suspected problem: %s" % (cause))
        log.exception("Could not monitor vm %s via %s due to: %s"
                      % (vmuuid, username, cause))
        return 1


def register_vm_for_monitoring(session, vmuuid):
    print("Registering the VM for monitoring.")
    docker_monitor_api.deregister_vm(vmuuid, session)
    docker_monitor_api.register_vm(vmuuid, session)
    print("Success.")


def main(argv=None):
    options = parse_options()
    if not ask_before_starting():
        return 1
    session = None
    try:
        session = api_helper.get_local_api_session()
        resultcode = push_ssh_key(session, options.vmuuid, options.username)
        if resultcode == 0:
            resultcode = verify_monitoring(session, options.vmuuid,
                                           options.username)
        if resultcode == 0:
            register_vm_for_monitoring(session, options.vmuuid)
    finally:
        if session != None:
            session.xenapi.session.logout()
    return resultcode


if __name__ == "__main__":
    sys.exit(main())
